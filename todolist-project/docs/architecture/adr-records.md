# 架构决策记录 (Architecture Decision Records)

> **项目**: TodoList 待办事项管理系统
> **版本**: 1.0
> **最后更新**: 2026-01-26

---

## ADR 索引

| ADR 编号 | 决策标题 | 状态 | 决策日期 | 决策者 |
|----------|----------|------|----------|--------|
| ADR-001 | 分层架构模式 | 已接受 | 2026-01-26 | 系统架构师 |
| ADR-002 | 技术栈选择 | 已接受 | 2026-01-26 | 技术团队 |
| ADR-003 | 数据库设计方法 | 已接受 | 2026-01-26 | 系统架构师 |
| ADR-004 | 认证授权策略 | 已接受 | 2026-01-26 | 安全架构师 |
| ADR-005 | API 设计规范 | 已接受 | 2026-01-26 | API 架构师 |

---

## ADR-001: 分层架构模式

### 状态
**已接受** (Accepted)

### 上下文

TodoList 系统是一个用于演示 SDLC 框架的待办事项管理应用。我们需要选择一个清晰、易懂、易于维护的架构模式。项目团队对 Java 企业级开发有经验，参考项目 ruoyi-example 采用了分层架构。

**需要考虑的问题**:
1. 如何组织代码结构，使其清晰易懂？
2. 如何确保关注点分离，降低耦合？
3. 如何支持单元测试和集成测试？
4. 如何平衡简单性和可扩展性？

### 决策

采用经典的**分层架构（Layered Architecture）**模式，将系统分为四层:

1. **Presentation Layer (表现层)**: REST API Controllers
2. **Business Layer (业务层)**: Service 接口和实现
3. **Persistence Layer (持久层)**: MyBatis-Plus Mappers
4. **Domain Layer (领域层)**: Entities, DTOs, Enums

**层次调用规则**: 上层可以调用下层，下层不能调用上层。

### 后果

**积极后果**:
- ✓ 结构清晰，易于理解和维护
- ✓ 关注点分离，降低层间耦合
- ✓ 每层可独立测试，提高可测试性
- ✓ 便于团队协作，不同开发者可专注不同层
- ✓ 与参考项目 ruoyi-example 一致，降低学习成本
- ✓ 适合 CRUD 类型应用，开发效率高

**消极后果**:
- ✗ 层间传递可能带来性能开销（对象转换）
- ✗ 可能出现"贫血模型"问题，业务逻辑分散
- ✗ 简单的 CRUD 操作可能需要经过多层
- ✗ 层间严格隔离可能限制灵活性

**缓解措施**:
- 使用 DTO 对象减少转换开销
- Service 层集中业务逻辑，避免贫血
- 对于简单查询，可在 Controller 中直接调用 Mapper（谨慎使用）
- 预留扩展点，支持未来架构演进

### 替代方案

**方案 1: MVC 模式 (Model-View-Controller)**
- **描述**: 传统的 Web MVC 架构
- **优点**: 成熟稳定，开发者熟悉
- **缺点**: 前后端分离后不再适用
- **决策**: 不采用，使用 RESTful API 替代

**方案 2: 六边形架构 (Hexagonal Architecture)**
- **描述**: 领域驱动设计（DDD）架构，核心业务逻辑独立
- **优点**: 业务逻辑清晰，易于测试
- **缺点**: 学习曲线陡峭，初期复杂度高
- **决策**: 不采用，业务简单，避免过度设计

**方案 3: 微服务架构 (Microservices Architecture)**
- **描述**: 将应用拆分为多个独立服务
- **优点**: 独立部署，技术栈灵活
- **缺点**: 分布式复杂度高，运维成本大
- **决策**: 不采用，单体应用足够

### 相关决策
- ADR-002: 技术栈选择（Spring Boot 支持分层架构）
- ADR-003: 数据库设计方法（MyBatis-Plus 适合分层架构）

### 决策日期
2026-01-26

### 决策者
系统架构师

---

## ADR-002: 技术栈选择

### 状态
**已接受** (Accepted)

### 上下文

项目需要选择一个成熟、稳定、高效的技术栈来实现 TodoList 系统。项目要求使用 Java 17 和 Spring Boot 3.2.0，需要考虑团队熟悉度、社区支持、学习成本和长期维护性。

**需要考虑的问题**:
1. 选择哪个后端框架？
2. 选择哪个 ORM 框架？
3. 选择哪个数据库？
4. 如何处理数据库迁移？
5. 如何实现 API 文档？

### 决策

**后端框架: Spring Boot 3.2.0**
- 理由: 成熟稳定，简化配置，社区活跃，文档完善
- 版本: 3.2.0 (基于 Jakarta EE 9+，支持 Java 17)

**ORM 框架: MyBatis-Plus 3.5.5**
- 理由: 在 MyBatis 基础上增强，简化 CRUD，代码生成，团队熟悉
- 版本: 3.5.5

**数据库: MySQL 8.0+**
- 理由: 开源免费，事务支持好，索引优化成熟，社区活跃
- 开发环境: H2 内存数据库（快速启动）

**数据库迁移: Flyway 9.x**
- 理由: 版本化 schema，自动升级，团队协作友好
- 版本: 9.x

**API 文档: Swagger/OpenAPI 2.x**
- 理由: 自动生成文档，支持在线测试
- 版本: 2.x (springdoc-openapi)

**认证: JWT (jjwt 0.12.x)**
- 理由: 无状态，跨域支持，移动端友好
- 版本: 0.12.x

### 后果

**积极后果**:
- ✓ 技术栈成熟，稳定可靠
- ✓ 社区活跃，问题容易解决
- ✓ 开发效率高，框架简化配置
- ✓ 团队熟悉，学习成本低
- ✓ 参考项目 ruoyi-example 使用相同技术栈
- ✓ Java 17 是 LTS 版本，长期支持

**消极后果**:
- ✗ Spring Boot 3.x 要求 Java 17，对旧 JDK 不兼容
- ✗ MyBatis-Plus 魔法较多，可能掩盖底层逻辑
- ✗ MySQL 需要独立部署和维护
- ✗ JWT Token 无法主动撤销（需要等待过期）

**缓解措施**:
- 文档中明确 Java 17 要求
- Code Review 确保正确使用 MyBatis-Plus
- 使用 Docker 简化 MySQL 部署
- 预留 Redis Token 黑名单功能（可选）

### 替代方案

**后端框架替代方案:**
- **Spring Framework**: 太重，配置复杂
- **Quarkus**: 启动快，但社区较小，学习成本高
- **Micronaut**: 现代化，但生态不如 Spring Boot
- **决策**: Spring Boot 是最佳选择

**ORM 框架替代方案:**
- **Spring Data JPA**: 更简洁，但团队不熟悉，复杂查询不如 MyBatis
- **纯 MyBatis**: 灵活，但 CRUD 代码量大，重复劳动
- **Hibernate**: 功能强大，但学习曲线陡峭
- **决策**: MyBatis-Plus 平衡了开发效率和灵活性

**数据库替代方案:**
- **PostgreSQL**: 功能更强大，但 MySQL 更普及，团队更熟悉
- **MongoDB**: 文档数据库，但不需要灵活 schema
- **H2**: 仅适合开发和测试，不适合生产
- **决策**: MySQL 是最佳选择

### 相关决策
- ADR-001: 分层架构模式（Spring Boot 支持分层架构）
- ADR-003: 数据库设计方法（Flyway 数据库迁移）
- ADR-004: 认证授权策略（JWT 认证）

### 决策日期
2026-01-26

### 决策者
技术团队

---

## ADR-003: 数据库设计方法

### 状态
**已接受** (Accepted)

### 上下文

项目需要管理数据库 schema 和版本。开发过程中会有多次数据库结构变更，需要一种可靠的方式来跟踪和应用这些变更。团队需要协作开发，确保每个人的数据库版本一致。

**需要考虑的问题**:
1. 如何版本化数据库 schema？
2. 如何自动应用数据库变更？
3. 如何保证团队开发环境一致？
4. 如何支持数据库回滚？
5. 如何与代码版本控制集成？

### 决策

采用 **Flyway** 进行数据库版本管理和迁移。

**迁移策略**:
- **版本化迁移**: 使用版本号命名 SQL 文件（如 `V1__init_schema.sql`）
- **增量式**: 每次变更创建新的迁移脚本
- **顺序执行**: 按版本号顺序执行迁移
- **自动应用**: 应用启动时自动检查并应用未执行的迁移

**命名规范**:
```
db/migration/
├── V1__init_schema.sql
├── V2__create_user_table.sql
├── V3__create_todo_table.sql
├── V4__create_category_table.sql
└── V5__create_todo_category_table.sql
```

**特点**:
- 使用 `V` 前缀表示版本化迁移
- 双下划线 `__` 分隔版本号和描述
- 描述使用下划线替代空格
- 每个迁移脚本只包含一个变更

### 后果

**积极后果**:
- ✓ 数据库版本化，变更历史清晰
- ✓ 自动应用迁移，减少人工操作
- ✓ 团队开发环境一致，避免版本冲突
- ✓ 支持多种数据库（MySQL, PostgreSQL, H2 等）
- ✓ 迁移脚本可审查，与代码同步
- ✓ 防止意外删除和修改
- ✓ 生产环境部署安全可靠

**消极后果**:
- ✗ 需要编写 SQL 迁移脚本，增加开发成本
- ✗ 迁移脚本编写不当可能导致失败
- ✗ 回滚操作需要额外编写脚本
- ✗ 多人开发时可能出现版本号冲突

**缓解措施**:
- 提供迁移脚本模板和编写指南
- Code Review 确保迁移脚本质量
- 使用 Flyway 的 Undo 功能（可选）
- 预留版本号段给不同开发者

### 替代方案

**方案 1: 手动管理 SQL 脚本**
- **描述**: 手动执行 SQL 脚本，维护变更日志
- **优点**: 灵活，无需额外工具
- **缺点**: 容易出错，版本管理困难，团队协作差
- **决策**: 不采用，缺乏自动化

**方案 2: Liquibase**
- **描述**: 类似 Flyway 的数据库迁移工具
- **优点**: 支持多种格式（XML, YAML, JSON, SQL）
- **缺点**: 配置复杂，学习曲线比 Flyway 陡峭
- **决策**: 不采用，Flyway 更简单

**方案 3: JPA/Hibernate 自动生成 DDL**
- **描述**: 通过 JPA 注解自动创建表结构
- **优点**: 方便，无需编写 SQL
- **缺点**: 难以控制，不适合生产环境，索引优化困难
- **决策**: 不采用，生产环境不可靠

**方案 4: 无迁移策略**
- **描述**: 直接修改数据库，不记录变更
- **优点**: 简单快速
- **缺点**: 无法回滚，版本混乱，团队协作困难
- **决策**: 不采用，不专业

### 相关决策
- ADR-001: 分层架构模式（数据访问层设计）
- ADR-002: 技术栈选择（MySQL 数据库）

### 决策日期
2026-01-26

### 决策者
系统架构师

---

## ADR-004: 认证授权策略

### 状态
**已接受** (Accepted)

### 上下文

系统需要实现用户认证和授权功能，确保只有合法用户才能访问资源，并且每个用户只能访问自己的数据。系统是前后端分离的 RESTful API，需要考虑安全性、性能和用户体验。

**需要考虑的问题**:
1. 使用什么认证机制？
2. 如何管理用户会话？
3. 如何保护 API 接口？
4. 如何实现数据隔离？
5. 如何防止安全攻击？

### 决策

采用 **JWT (JSON Web Token)** 进行无状态认证，配合 **Spring Security** 实现安全控制。

**认证流程**:
1. 用户使用用户名和密码登录
2. 服务端验证凭证，生成 JWT Token
3. 客户端存储 Token（LocalStorage/Cookie）
4. 后续请求在 Header 中携带 Token: `Authorization: Bearer <token>`
5. 服务端验证 Token 有效性，提取用户信息

**Token 结构**:
```json
{
  "user_id": 123,
  "username": "testuser",
  "exp": 1706659200,
  "iat": 1706572800
}
```

**安全措施**:
- Token 有效期: 24 小时
- 密码加密: BCrypt 哈希算法
- 登录失败限制: 5 次后锁定 30 分钟
- 密码复杂度: 至少 8 位，包含字母和数字
- Token 签名: 使用强密钥（HS256）

**授权策略**:
- 基于用户的数据隔离（用户只能访问自己的数据）
- Service 层自动添加 `user_id` 过滤条件
- Controller 层验证资源所有权

### 后果

**积极后果**:
- ✓ 无状态认证，服务器不存储会话，易于扩展
- ✓ 跨域支持好，适合前后端分离
- ✓ 移动端友好，支持多种客户端
- ✓ 性能优秀，无需查询 Session
- ✓ Token 自包含，携带用户信息
- ✓ 安全性高，支持签名验证

**消极后果**:
- ✗ Token 无法主动撤销（需等待过期）
- ✗ Token 泄露后无法立即失效
- ✗ Token 存储在 LocalStorage 容易被 XSS 攻击
- ✗ Refresh Token 机制增加复杂度（可选）

**缓解措施**:
- Token 有效期设置为合理时长（24小时）
- 生产环境使用 HTTPS 加密传输
- 敏感操作可要求重新输入密码
- 预留 Token 黑名单功能（使用 Redis）
- 提示用户使用 HttpOnly Cookie（可选）

### 替代方案

**方案 1: Session + Cookie**
- **描述**: 传统的有状态认证，Session 存储在服务器
- **优点**: 服务器可控制会话，可随时撤销
- **缺点**: 服务器需要存储会话，扩展性差，不适合分布式
- **决策**: 不采用，不适合前后端分离和微服务

**方案 2: OAuth 2.0**
- **描述**: 开放授权标准，支持第三方登录
- **优点**: 标准化，安全性高，支持多种授权模式
- **缺点**: 复杂度高，不适合简单应用
- **决策**: 不采用，过度设计，未来可扩展

**方案 3: API Key**
- **描述**: 使用 API Key 进行认证
- **优点**: 简单，易于实现
- **缺点**: 安全性差，无法区分用户，无过期机制
- **决策**: 不采用，安全性不足

### 相关决策
- ADR-001: 分层架构模式（认证拦截器在各层）
- ADR-002: 技术栈选择（Spring Security + JWT）
- ADR-005: API 设计规范（Token 在 Header 中传递）

### 决策日期
2026-01-26

### 决策者
安全架构师

---

## ADR-005: API 设计规范

### 状态
**已接受** (Accepted)

### 上下文

系统对外提供 RESTful API 接口，需要设计清晰、一致、易用的 API 规范。API 是前后端交互的契约，设计质量直接影响开发效率和用户体验。

**需要考虑的问题**:
1. 如何设计 URL 结构？
2. 如何使用 HTTP 方法？
3. 如何返回响应数据？
4. 如何处理错误？
5. 如何实现版本控制？

### 决策

遵循 **RESTful API 设计规范**，采用标准化的接口设计。

**URL 设计**:
```
/api/v1/{resource}/{id}

示例:
GET    /api/v1/todos              # 获取待办列表
GET    /api/v1/todos/123          # 获取指定待办
POST   /api/v1/todos              # 创建待办
PUT    /api/v1/todos/123          # 更新待办（全部）
PATCH  /api/v1/todos/123          # 更新待办（部分）
DELETE /api/v1/todos/123          # 删除待办
```

**HTTP 方法语义**:
- **GET**: 查询资源，幂等，安全
- **POST**: 创建资源，非幂等，不安全
- **PUT**: 更新资源（全部字段），幂等，不安全
- **PATCH**: 更新资源（部分字段），幂等，不安全
- **DELETE**: 删除资源，幂等，不安全

**状态码规范**:
- **200 OK**: 查询成功
- **201 Created**: 创建成功
- **204 No Content**: 删除成功（无返回内容）
- **400 Bad Request**: 参数错误
- **401 Unauthorized**: 未认证
- **403 Forbidden**: 无权限
- **404 Not Found**: 资源不存在
- **500 Internal Server Error**: 服务器错误

**统一响应格式**:
```json
{
  "code": 200,
  "message": "success",
  "data": {...},
  "timestamp": "2026-01-26T12:00:00Z"
}
```

**版本控制**:
- 使用 URL 路径版本: `/api/v1/`, `/api/v2/`
- 主版本号变更时创建新版本
- 向后兼容的小变更不改变版本号

### 后果

**积极后果**:
- ✓ API 设计清晰，易于理解和使用
- ✓ 符合 RESTful 规范，标准化
- ✓ HTTP 方法语义明确，降低学习成本
- ✓ 统一响应格式，前端处理简单
- ✓ 版本控制支持，平滑升级
- ✓ 错误处理规范，调试方便
- ✓ 支持自动生成 API 文档（Swagger）

**消极后果**:
- ✗ RESTful 规范严格，可能不适用所有场景
- ✗ URL 较长，可读性略差
- ✗ 版本管理增加维护成本
- ✗ 统一响应格式可能增加数据冗余

**缓解措施**:
- 对于复杂查询，可使用 GraphQL（未来扩展）
- 使用 URL 缩短服务（可选）
- 版本变更前充分评估兼容性
- 响应格式支持压缩（Gzip）

### 替代方案

**方案 1: RPC 风格 API**
- **描述**: 使用动作导向的 URL，如 `/api/v1/createTodo`
- **优点**: 直观，易于理解
- **缺点**: 不符合 RESTful 规范，不支持 HTTP 语义
- **决策**: 不采用，不标准化

**方案 2: GraphQL**
- **描述**: 使用 GraphQL 查询语言
- **优点**: 灵活，按需获取数据
- **缺点**: 学习曲线陡峭，缓存复杂
- **决策**: 不采用，过度设计，未来可扩展

**方案 3: gRPC**
- **描述**: 使用 Protocol Buffers 和 HTTP/2
- **优点**: 性能高，类型安全
- **缺点**: 不支持浏览器，调试困难
- **决策**: 不采用，不适合前后端分离

### 相关决策
- ADR-001: 分层架构模式（Controller 层实现 API）
- ADR-002: 技术栈选择（Spring Boot Web MVC）
- ADR-004: 认证授权策略（Token 在 Header 中传递）

### 决策日期
2026-01-26

### 决策者
API 架构师

---

## ADR 模板

```markdown
## ADR-XXX: [决策标题]

### 状态
[拟议 | 已接受 | 已弃用 | 已取代]

### 上下文
[描述面临的问题或需要做出的决策的背景]
[包括约束条件、技术限制、业务需求等]

### 决策
[描述我们做出的决定]
[包括具体方案、实现方式、技术选型等]

### 后果
**积极后果**:
- ✓ [好处 1]
- ✓ [好处 2]

**消极后果**:
- ✗ [坏处 1]
- ✗ [坏处 2]

**缓解措施**:
- [如何减轻消极后果]

### 替代方案
**方案 1: [方案名称]**
- **描述**: [简要描述]
- **优点**: [优点]
- **缺点**: [缺点]
- **决策**: [接受/拒绝]

### 相关决策
- [链接到相关 ADR]

### 决策日期
[日期]

### 决策者
[角色/姓名]
```

---

## 参考资源

- [Architecture Decision Records](https://adr.github.io/)
- [Microsoft Architecture Decision Records](https://docs.microsoft.com/en-us/azure/architecture/patterns/decision-records)
- [ThoughtWorks Technology Radar](https://www.thoughtworks.com/radar)
