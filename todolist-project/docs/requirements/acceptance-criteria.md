# 验收标准

> **项目**: TodoList 待办事项管理系统
> **版本**: 1.0
> **最后更新**: 2026-01-26

---

## 验收标准概览

| AC ID | 用户故事 | 标准描述 | 优先级 | 状态 |
|-------|----------|----------|--------|------|
| AC-001 | US-001 | 用户注册功能验证 | P0 | 待验证 |
| AC-002 | US-001 | 用户名唯一性验证 | P0 | 待验证 |
| AC-003 | US-001 | 密码复杂度验证 | P0 | 待验证 |
| AC-004 | US-001 | 用户登录功能验证 | P0 | 待验证 |
| AC-005 | US-001 | 登录失败处理 | P0 | 待验证 |
| AC-006 | US-001 | 登录失败次数限制 | P0 | 待验证 |
| AC-007 | US-002 | 创建待办事项基本功能 | P0 | 待验证 |
| AC-008 | US-002 | 标题长度验证 | P0 | 待验证 |
| AC-009 | US-002 | 完整字段创建待办事项 | P0 | 待验证 |
| AC-010 | US-002 | 未登录用户创建限制 | P0 | 待验证 |
| AC-011 | US-003 | 查看待办事项列表 | P0 | 待验证 |
| AC-012 | US-003 | 分页功能验证 | P0 | 待验证 |
| AC-013 | US-003 | 空列表显示 | P0 | 待验证 |
| AC-014 | US-003 | 数据隔离验证 | P0 | 待验证 |
| AC-015 | US-004 | 更新待办事项 | P0 | 待验证 |
| AC-016 | US-004 | 部分字段更新 | P0 | 待验证 |
| AC-017 | US-004 | 更新权限验证 | P0 | 待验证 |
| AC-018 | US-005 | 删除待办事项 | P0 | 待验证 |
| AC-019 | US-005 | 删除权限验证 | P0 | 待验证 |
| AC-020 | US-005 | 批量删除功能 | P0 | 待验证 |
| AC-021 | US-006 | 标记待办事项完成 | P0 | 待验证 |
| AC-022 | US-006 | 状态切换功能 | P0 | 待验证 |
| AC-023 | US-007 | 创建分类标签 | P1 | 待验证 |
| AC-024 | US-007 | 分类名称唯一性 | P1 | 待验证 |
| AC-025 | US-007 | 删除分类验证 | P1 | 待验证 |
| AC-026 | US-008 | 修改密码功能 | P1 | 待验证 |
| AC-027 | US-009 | 搜索待办事项 | P1 | 待验证 |
| AC-028 | US-010 | 过滤待办事项 | P1 | 待验证 |

---

## 验收标准详情

## AC-001: 用户注册功能验证

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
用户能够使用唯一的用户名和符合复杂度要求的密码成功注册账户，密码以加密形式存储在数据库中，注册成功后自动登录。

### 验证场景

#### 场景 1: 正常注册流程
**Given** 用户访问注册页面 `/api/auth/register`
**When** 用户提交以下数据:
```json
{
  "username": "testuser",
  "password": "Test1234",
  "confirmPassword": "Test1234"
}
```
**Then** 系统应该:
- 返回 HTTP 状态码 201 Created
- 返回用户信息（不包含密码）
- 返回 JWT Token
- 数据库中创建用户记录
- 密码字段使用 BCrypt 加密（长度为 60 字符）
- 自动登录用户

**测试用例**: TC-001-01

#### 场景 2: 密码加密验证
**Given** 用户成功注册账户
**When** 查询数据库 `sys_user` 表
**Then** 密码字段应该:
- 以 `$2a$` 或 `$2b$` 开头（BCrypt 标识）
- 长度为 60 字符
- 不包含明文密码

**测试用例**: TC-001-02

#### 场景 3: 用户名包含特殊字符
**Given** 用户访问注册页面
**When** 用户提交用户名 `user@#$%`
**Then** 系统应该返回 400 Bad Request 并提示"用户名只能包含字母、数字和下划线"

**测试用例**: TC-001-03

### 验证方法
- [x] 自动化测试（JUnit + Mockito）
- [x] 手动测试（Postman/Apifox）
- [x] 数据库验证
- [ ] 代码审查

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 密码加密必须在存储前完成

---

## AC-002: 用户名唯一性验证

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
系统必须确保用户名的唯一性，拒绝重复的用户名注册。

### 验证场景

#### 场景 1: 重复用户名注册
**Given** 数据库中已存在用户名 `testuser`
**When** 新用户尝试使用用户名 `testuser` 注册
**Then** 系统应该:
- 返回 HTTP 状态码 400 Bad Request
- 返回错误消息 "用户名已存在"
- 不创建新用户记录

**测试用例**: TC-002-01

#### 场景 2: 大小写敏感验证
**Given** 数据库中已存在用户名 `TestUser`
**When** 用户尝试使用 `testuser`（不同大小写）注册
**Then** 系统应该:
- 根据业务规则决定是否允许（建议：不区分大小写）
- 返回相应的错误消息

**测试用例**: TC-002-02

#### 场景 3: 并发注册相同用户名
**Given** 两个用户同时使用相同用户名注册
**When** 两个请求同时到达服务器
**Then** 系统应该:
- 只有一个请求成功
- 另一个请求返回"用户名已存在"
- 使用数据库唯一索引保证

**测试用例**: TC-002-03

### 验证方法
- [x] 自动化测试
- [x] 并发测试
- [x] 数据库约束验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 数据库必须添加唯一索引

---

## AC-003: 密码复杂度验证

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
系统必须验证密码的复杂度，确保密码至少 8 位且包含字母和数字。

### 验证场景

#### 场景 1: 符合要求的密码
**Given** 用户访问注册页面
**When** 用户提交符合要求的密码:
- `Test1234` - 8 位，包含字母和数字
- `MyPass123` - 9 位，包含字母和数字
**Then** 系统应该接受密码并创建用户

**测试用例**: TC-003-01

#### 场景 2: 密码少于 8 位
**Given** 用户访问注册页面
**When** 用户提交密码 `Test123`（7 位）
**Then** 系统应该返回 400 Bad Request 并提示"密码必须至少 8 位"

**测试用例**: TC-003-02

#### 场景 3: 密码只包含数字
**Given** 用户访问注册页面
**When** 用户提交密码 `12345678`（只包含数字）
**Then** 系统应该返回 400 Bad Request 并提示"密码必须包含字母和数字"

**测试用例**: TC-003-03

#### 场景 4: 密码只包含字母
**Given** 用户访问注册页面
**When** 用户提交密码 `abcdefgh`（只包含字母）
**Then** 系统应该返回 400 Bad Request 并提示"密码必须包含字母和数字"

**测试用例**: TC-003-04

#### 场景 5: 两次密码不一致
**Given** 用户访问注册页面
**When** 用户输入密码 `Test1234` 和确认密码 `Test5678`
**Then** 系统应该返回 400 Bad Request 并提示"两次输入的密码不一致"

**测试用例**: TC-003-05

### 验证方法
- [x] 自动化测试
- [x] 参数化测试
- [x] 正则表达式验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 密码验证应该在前后端都实现

---

## AC-004: 用户登录功能验证

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
用户能够使用正确的用户名和密码成功登录，系统生成并返回有效的 JWT Token。

### 验证场景

#### 场景 1: 正常登录流程
**Given** 数据库中存在用户 `testuser`，密码为 `Test1234`
**When** 用户向 `/api/auth/login` 提交:
```json
{
  "username": "testuser",
  "password": "Test1234"
}
```
**Then** 系统应该:
- 返回 HTTP 状态码 200 OK
- 返回 JWT Token
- Token 包含用户 ID 和用户名
- Token 有效期为 24 小时
- 返回用户基本信息

**测试用例**: TC-004-01

#### 场景 2: Token 格式验证
**Given** 用户成功登录
**When** 检查返回的 JWT Token
**Then** Token 应该:
- 包含三部分，用 `.` 分隔
- 可以使用 Base64 解码
- Header 包含算法信息
- Payload 包含用户信息（user_id, username）
- 包含过期时间（exp）

**测试用例**: TC-004-02

#### 场景 3: Token 在后续请求中使用
**Given** 用户已登录并获得 Token
**When** 用户在请求头中携带 `Authorization: Bearer <token>`
**Then** 系统应该:
- 验证 Token 有效性
- 允许访问受保护资源
- 返回正确数据

**测试用例**: TC-004-03

### 验证方法
- [x] 自动化测试
- [x] JWT 库验证
- [x] Token 解码和验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: JWT Secret 必须安全存储

---

## AC-005: 登录失败处理

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
系统必须正确处理登录失败情况，包括错误的用户名或密码。

### 验证场景

#### 场景 1: 用户名不存在
**Given** 数据库中不存在用户 `nonexistent`
**When** 用户尝试登录:
```json
{
  "username": "nonexistent",
  "password": "Test1234"
}
```
**Then** 系统应该:
- 返回 HTTP 状态码 401 Unauthorized
- 返回错误消息 "用户名或密码错误"
- 不透露用户名是否存在（安全考虑）
- 不生成 Token

**测试用例**: TC-005-01

#### 场景 2: 密码错误
**Given** 数据库中存在用户 `testuser`，密码为 `Test1234`
**When** 用户使用错误密码 `WrongPass` 登录
**Then** 系统应该:
- 返回 HTTP 状态码 401 Unauthorized
- 返回错误消息 "用户名或密码错误"
- 不生成 Token
- 记录失败尝试

**测试用例**: TC-005-02

#### 场景 3: 用户名为空
**Given** 用户访问登录页面
**When** 用户只提交密码，不提交用户名
**Then** 系统应该返回 400 Bad Request 并提示"用户名不能为空"

**测试用例**: TC-005-03

### 验证方法
- [x] 自动化测试
- [x] 安全测试
- [x] 日志验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 错误消息应该模糊化，防止用户枚举

---

## AC-006: 登录失败次数限制

**关联用户故事**: US-001 - 用户注册和登录

**优先级**: P0

### 标准描述
系统必须限制用户登录失败次数，防止暴力破解攻击。

### 验证场景

#### 场景 1: 连续 5 次登录失败
**Given** 用户 `testuser` 连续 5 次使用错误密码登录
**When** 用户尝试第 6 次登录
**Then** 系统应该:
- 锁定账户 30 分钟
- 返回错误消息 "账户已锁定，请 30 分钟后再试"
- 即使用户使用正确密码也无法登录

**测试用例**: TC-006-01

#### 场景 2: 锁定时间结束后解锁
**Given** 用户账户已被锁定
**When** 等待 30 分钟后
**Then** 系统应该:
- 自动解锁账户
- 允许用户使用正确密码登录

**测试用例**: TC-006-02

#### 场景 3: 失败次数重置
**Given** 用户已失败 3 次登录
**When** 用户成功登录
**Then** 系统应该:
- 重置失败计数器为 0
- 下次失败重新计数

**测试用例**: TC-006-03

#### 场景 4: 不同用户独立计数
**Given** 用户 A 失败 5 次登录被锁定
**When** 用户 B 尝试登录
**Then** 系统应该:
- 不影响用户 B 的登录
- 用户 B 可以正常登录

**测试用例**: TC-006-04

### 验证方法
- [x] 自动化测试
- [x] 时间相关测试
- [x] 并发测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 建议使用 Redis 存储失败计数，支持分布式部署

---

## AC-007: 创建待办事项基本功能

**关联用户故事**: US-002 - 创建待办事项

**优先级**: P0

### 标准描述
已登录用户能够创建包含必填字段的待办事项，系统返回完整信息。

### 验证场景

#### 场景 1: 创建最小待办事项
**Given** 用户已登录
**When** 用户向 `/api/todos` POST:
```json
{
  "title": "完成项目文档"
}
```
**Then** 系统应该:
- 返回 HTTP 状态码 201 Created
- 创建待办事项
- 返回包含 ID 的完整待办事项信息
- 默认状态为 "PENDING"
- 默认优先级为 "MEDIUM"
- 关联到当前登录用户
- 设置创建时间和更新时间

**测试用例**: TC-007-01

#### 场景 2: 创建完整待办事项
**Given** 用户已登录并创建了分类 "工作"
**When** 用户提交完整数据:
```json
{
  "title": "完成项目报告",
  "description": "需要在周五之前完成",
  "priority": "HIGH",
  "dueDate": "2026-01-30",
  "categoryIds": [1]
}
```
**Then** 系统应该:
- 创建包含所有字段的待办事项
- 正确关联分类
- 返回完整的待办事项信息

**测试用例**: TC-007-02

### 验证方法
- [x] 自动化测试
- [x] 数据库验证
- [x] API 测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 需要验证数据库中的关联关系

---

## AC-008: 标题长度验证

**关联用户故事**: US-002 - 创建待办事项

**优先级**: P0

### 标准描述
系统必须验证待办事项标题的长度，限制为 1-200 字符。

### 验证场景

#### 场景 1: 标题为空
**Given** 用户已登录
**When** 用户提交空标题 `""` 或 `null`
**Then** 系统应该返回 400 Bad Request 并提示"标题不能为空"

**测试用例**: TC-008-01

#### 场景 2: 标题超过 200 字符
**Given** 用户已登录
**When** 用户提交 201 字符的标题
**Then** 系统应该返回 400 Bad Request 并提示"标题长度不能超过 200 字符"

**测试用例**: TC-008-02

#### 场景 3: 标题正好 200 字符
**Given** 用户已登录
**When** 用户提交 200 字符的标题
**Then** 系统应该成功创建待办事项

**测试用例**: TC-008-03

#### 场景 4: 描述长度验证
**Given** 用户已登录
**When** 用户提交超过 1000 字符的描述
**Then** 系统应该返回 400 Bad Request 并提示"描述长度不能超过 1000 字符"

**测试用例**: TC-008-04

### 验证方法
- [x] 自动化测试
- [x] 参数化测试
- [x] 边界值测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 需要在数据库层面也添加长度限制

---

## AC-009: 完整字段创建待办事项

**关联用户故事**: US-002 - 创建待办事项

**优先级**: P0

### 标准描述
用户能够创建包含所有可选字段的待办事项，所有字段都被正确保存。

### 验证场景

#### 场景 1: 包含所有字段
**Given** 用户已登录
**When** 用户提交包含所有字段的数据
**Then** 系统应该:
- 保存标题
- 保存描述
- 保存优先级（HIGH/MEDIUM/LOW）
- 保存截止日期（日期格式）
- 关联分类（多个）
- 设置默认状态为 PENDING
- 返回完整的待办对象

**测试用例**: TC-009-01

#### 场景 2: 优先级枚举验证
**Given** 用户已登录
**When** 用户提交无效的优先级 `INVALID`
**Then** 系统应该返回 400 Bad Request 并提示"优先级必须是 HIGH、MEDIUM 或 LOW"

**测试用例**: TC-009-02

#### 场景 3: 日期格式验证
**Given** 用户已登录
**When** 用户提交无效的日期格式 `2026/01/30`
**Then** 系统应该返回 400 Bad Request 并提示"日期格式不正确"

**测试用例**: TC-009-03

### 验证方法
- [x] 自动化测试
- [x] 数据库验证
- [x] 字段类型验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 日期格式应该统一使用 ISO 8601

---

## AC-010: 未登录用户创建限制

**关联用户故事**: US-002 - 创建待办事项

**优先级**: P0

### 标准描述
未登录用户无法创建待办事项，系统返回 401 错误。

### 验证场景

#### 场景 1: 不携带 Token
**Given** 用户未登录
**When** 用户向 `/api/todos` POST 数据（不携带 Token）
**Then** 系统应该:
- 返回 HTTP 状态码 401 Unauthorized
- 返回错误消息 "未授权，请先登录"
- 不创建待办事项

**测试用例**: TC-010-01

#### 场景 2: Token 过期
**Given** 用户的 Token 已过期
**When** 用户携带过期 Token 创建待办事项
**Then** 系统应该:
- 返回 HTTP 状态码 401 Unauthorized
- 返回错误消息 "Token 已过期，请重新登录"

**测试用例**: TC-010-02

#### 场景 3: Token 格式错误
**Given** 用户未登录
**When** 用户携带格式错误的 Token
**Then** 系统应该返回 401 Unauthorized

**测试用例**: TC-010-03

### 验证方法
- [x] 自动化测试
- [x] 安全测试
- [x] 认证拦截器验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 所有受保护接口都必须验证 Token

---

## AC-011: 查看待办事项列表

**关联用户故事**: US-003 - 查看待办事项列表

**优先级**: P0

### 标准描述
用户能够查看自己的待办事项列表，按创建时间倒序排列，支持分页。

### 验证场景

#### 场景 1: 查看列表基本功能
**Given** 用户已登录并创建了 25 个待办事项
**When** 用户向 `/api/todos?page=1&size=20` GET
**Then** 系统应该:
- 返回 HTTP 状态码 200 OK
- 返回第一页的 20 个待办事项
- 按创建时间倒序排列
- 返回分页信息（total, page, size）
- 只返回当前用户的待办事项

**测试用例**: TC-011-01

#### 场景 2: 空列表
**Given** 用户已登录但未创建待办事项
**When** 用户向 `/api/todos` GET
**Then** 系统应该:
- 返回空数组 `[]`
- total 为 0

**测试用例**: TC-011-02

#### 场景 3: 排序验证
**Given** 用户已登录并创建了多个待办事项
**When** 用户查看列表
**Then** 最新的待办事项应该出现在列表顶部
**When** 用户指定排序 `sortBy=dueDate&order=asc`
**Then** 系统应该按截止日期升序排列

**测试用例**: TC-011-03

### 验证方法
- [x] 自动化测试
- [x] 分页测试
- [x] 排序测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 分页参数需要验证合法性

---

## AC-012: 分页功能验证

**关联用户故事**: US-003 - 查看待办事项列表

**优先级**: P0

### 标准描述
系统正确处理分页参数，返回正确的数据和分页信息。

### 验证场景

#### 场景 1: 基本分页
**Given** 用户有 25 个待办事项
**When** 用户请求第 1 页，每页 20 条
**Then** 系统应该:
- 返回 20 个待办事项
- total 为 25
- page 为 1
- size 为 20
- totalPages 为 2

**测试用例**: TC-012-01

#### 场景 2: 请求第 2 页
**Given** 用户有 25 个待办事项
**When** 用户请求第 2 页，每页 20 条
**Then** 系统应该:
- 返回 5 个待办事项
- page 为 2
- 总数仍为 25

**测试用例**: TC-012-02

#### 场景 3: 请求超出范围的页
**Given** 用户有 25 个待办事项
**When** 用户请求第 10 页
**Then** 系统应该:
- 返回空数组
- 或返回 404 Not Found

**测试用例**: TC-012-03

#### 场景 4: 自定义分页大小
**Given** 用户有 100 个待办事项
**When** 用户请求 page=1, size=50
**Then** 系统应该:
- 返回 50 个待办事项
- totalPages 为 2

**测试用例**: TC-012-04

### 验证方法
- [x] 自动化测试
- [x] 边界值测试
- [x] 分页计算验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 分页大小应该有最大限制（如 100）

---

## AC-013: 空列表显示

**关联用户故事**: US-003 - 查看待办事项列表

**优先级**: P0

### 标准描述
用户没有待办事项时，系统返回空列表而不是错误。

### 验证场景

#### 场景 1: 新用户空列表
**Given** 用户刚注册并登录
**When** 用户访问待办事项列表
**Then** 系统应该:
- 返回 HTTP 状态码 200 OK
- 返回空数组 `[]`
- total 为 0
- 不显示错误

**测试用例**: TC-013-01

#### 场景 2: 所有待办事项已删除
**Given** 用户创建了待办事项后全部删除
**When** 用户访问待办事项列表
**Then** 系统应该返回空数组

**测试用例**: TC-013-02

### 验证方法
- [x] 自动化测试
- [x] 边界条件测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 空列表应该返回友好提示

---

## AC-014: 数据隔离验证

**关联用户故事**: US-003 - 查看待办事项列表

**优先级**: P0

### 标准描述
用户只能查看自己的待办事项，无法查看其他用户的数据。

### 验证场景

#### 场景 1: 用户数据隔离
**Given** 用户 A 创建了待办事项 "任务A"
**And** 用户 B 创建了待办事项 "任务B"
**When** 用户 A 查看待办事项列表
**Then** 系统应该:
- 只显示 "任务A"
- 不显示 "任务B"
**When** 用户 B 查看待办事项列表
**Then** 系统应该:
- 只显示 "任务B"
- 不显示 "任务A"

**测试用例**: TC-014-01

#### 场景 2: 尝试访问其他用户的待办事项
**Given** 用户 A 创建了待办事项 ID=1
**When** 用户 B 尝试访问 `/api/todos/1`
**Then** 系统应该:
- 返回 HTTP 状态码 403 Forbidden
- 或返回 404 Not Found（推荐，防止信息泄露）
- 不返回待办事项数据

**测试用例**: TC-014-02

#### 场景 3: 数据库查询验证
**Given** 用户 A 和用户 B 都有数据
**When** 验证数据库查询
**Then** 查询应该包含 `WHERE user_id = ?` 条件

**测试用例**: TC-014-03

### 验证方法
- [x] 自动化测试
- [x] 安全测试
- [x] 数据库查询审查
- [x] 渗透测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 这是关键安全特性，必须严格测试

---

## AC-015: 更新待办事项

**关联用户故事**: US-004 - 更新待办事项

**优先级**: P0

### 标准描述
用户能够更新自己的待办事项的所有可编辑字段。

### 验证场景

#### 场景 1: 更新单个字段
**Given** 用户创建了待办事项 ID=1，标题为 "原标题"
**When** 用户向 `/api/todos/1` PUT:
```json
{
  "title": "新标题"
}
```
**Then** 系统应该:
- 返回 HTTP 状态码 200 OK
- 更新标题为 "新标题"
- 其他字段保持不变
- 更新 update_time 字段
- 返回更新后的完整待办事项

**测试用例**: TC-015-01

#### 场景 2: 更新多个字段
**Given** 用户创建了待办事项
**When** 用户更新标题、描述、优先级
**Then** 系统应该:
- 更新所有指定字段
- 未指定的字段保持不变
- 返回更新后的完整数据

**测试用例**: TC-015-02

#### 场景 3: 更新不存在的待办事项
**Given** 用户已登录
**When** 用户尝试更新 ID=999 的待办事项
**Then** 系统应该返回 404 Not Found

**测试用例**: TC-015-03

### 验证方法
- [x] 自动化测试
- [x] 数据库验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 需要考虑并发更新（乐观锁）

---

## AC-016: 部分字段更新

**关联用户故事**: US-004 - 更新待办事项

**优先级**: P0

### 标准描述
支持 PATCH 方式部分更新字段，只更新提供的字段。

### 验证场景

#### 场景 1: PATCH 部分更新
**Given** 用户创建了待办事项 ID=1
**When** 用户向 `/api/todos/1` PATCH:
```json
{
  "priority": "HIGH"
}
```
**Then** 系统应该:
- 只更新 priority 字段
- 其他字段（title、description等）保持不变
- 返回更新后的完整待办事项

**测试用例**: TC-016-01

#### 场景 2: 空请求体
**Given** 用户创建了待办事项
**When** 用户提交空的 PATCH 请求 `{}`
**Then** 系统应该:
- 返回 400 Bad Request
- 或返回原数据（不做任何更新）

**测试用例**: TC-016-02

### 验证方法
- [x] 自动化测试
- [x] API 规范验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: PATCH 是可选功能，PUT 可以覆盖

---

## AC-017: 更新权限验证

**关联用户故事**: US-004 - 更新待办事项

**优先级**: P0

### 标准描述
用户只能更新自己的待办事项，无法更新其他用户的待办事项。

### 验证场景

#### 场景 1: 尝试更新其他用户的待办事项
**Given** 用户 A 创建了待办事项 ID=1
**When** 用户 B 尝试更新 `/api/todos/1`
**Then** 系统应该:
- 返回 HTTP 状态码 403 Forbidden
- 或返回 404 Not Found
- 不更新待办事项
- 不泄露数据

**测试用例**: TC-017-01

#### 场景 2: 未登录用户更新
**Given** 用户创建了待办事项 ID=1
**When** 未登录用户尝试更新
**Then** 系统应该返回 401 Unauthorized

**测试用例**: TC-017-02

### 验证方法
- [x] 自动化测试
- [x] 权限测试
- [x] 安全测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 权限检查是必须的

---

## AC-018: 删除待办事项

**关联用户故事**: US-005 - 删除待办事项

**优先级**: P0

### 标准描述
用户能够软删除自己的待办事项，删除后不再出现在列表中。

### 验证场景

#### 场景 1: 软删除待办事项
**Given** 用户创建了待办事项 ID=1
**When** 用户向 `/api/todos/1` DELETE
**Then** 系统应该:
- 返回 HTTP 状态码 200 OK 或 204 No Content
- 设置 deleted=true
- 设置 deleted_at 时间戳
- 待办事项不再出现在列表中
- 数据库中仍保留记录

**测试用例**: TC-018-01

#### 场景 2: 删除后查询
**Given** 用户已删除待办事项 ID=1
**When** 用户尝试访问 `/api/todos/1`
**Then** 系统应该返回 404 Not Found

**测试用例**: TC-018-02

#### 场景 3: 删除不存在的待办事项
**Given** 用户已登录
**When** 用户删除 ID=999 的待办事项
**Then** 系统应该返回 404 Not Found

**测试用例**: TC-018-03

### 验证方法
- [x] 自动化测试
- [x] 数据库验证
- [x] 软删除机制验证

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定
**备注**: 必须使用软删除，保留数据

---

## AC-019: 删除权限验证

**关联用户故事**: US-005 - 删除待办事项

**优先级**: P0

### 标准描述
用户只能删除自己的待办事项，无法删除其他用户的待办事项。

### 验证场景

#### 场景 1: 尝试删除其他用户的待办事项
**Given** 用户 A 创建了待办事项 ID=1
**When** 用户 B 尝试删除 `/api/todos/1`
**Then** 系统应该:
- 返回 HTTP 状态码 403 Forbidden
- 或返回 404 Not Found
- 不删除待办事项

**测试用例**: TC-019-01

#### 场景 2: 未登录用户删除
**Given** 用户创建了待办事项
**When** 未登录用户尝试删除
**Then** 系统应该返回 401 Unauthorized

**测试用例**: TC-019-02

### 验证方法
- [x] 自动化测试
- [x] 权限测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-020: 批量删除功能

**关联用户故事**: US-005 - 删除待办事项

**优先级**: P0

### 标准描述
用户能够批量删除多个待办事项。

### 验证场景

#### 场景 1: 批量删除
**Given** 用户创建了待办事项 ID=1,2,3
**When** 用户向 `/api/todos/batch-delete` POST:
```json
{
  "ids": [1, 2, 3]
}
```
**Then** 系统应该:
- 删除所有 3 个待办事项
- 返回删除成功消息
- 返回删除数量 "已删除 3 个待办事项"

**测试用例**: TC-020-01

#### 场景 2: 批量删除包含其他用户的待办事项
**Given** 用户 A 和用户 B 都有数据
**When** 用户 A 尝试批量删除包含用户 B 的待办事项
**Then** 系统应该:
- 只删除用户 A 的待办事项
- 跳过用户 B 的待办事项
- 返回实际删除的数量

**测试用例**: TC-020-02

#### 场景 3: 空数组
**Given** 用户已登录
**When** 用户提交空 ids 数组
**Then** 系统应该返回 400 Bad Request

**测试用例**: TC-020-03

### 验证方法
- [x] 自动化测试
- [x] 批量操作测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-021: 标记待办事项完成

**关联用户故事**: US-006 - 标记待办事项完成状态

**优先级**: P0

### 标准描述
用户能够将待办事项标记为已完成或未完成。

### 验证场景

#### 场景 1: 标记为已完成
**Given** 用户创建了待办事项 ID=1，状态为 PENDING
**When** 用户向 `/api/todos/1/complete` POST
**Then** 系统应该:
- 更新状态为 COMPLETED
- 设置 completed_at 时间戳
- 返回更新后的待办事项

**测试用例**: TC-021-01

#### 场景 2: 标记为未完成
**Given** 用户有待办事项 ID=1，状态为 COMPLETED
**When** 用户向 `/api/todos/1/incomplete` POST
**Then** 系统应该:
- 更新状态为 PENDING
- 清除 completed_at 时间戳
- 返回更新后的待办事项

**测试用例**: TC-021-02

#### 场景 3: 切换状态
**Given** 用户有待办事项
**When** 用户向 `/api/todos/1/toggle-status` POST
**Then** 系统应该:
- 如果状态是 PENDING，改为 COMPLETED
- 如果状态是 COMPLETED，改为 PENDING
- 返回更新后的待办事项

**测试用例**: TC-021-03

### 验证方法
- [x] 自动化测试
- [x] 状态转换测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-022: 状态切换功能

**关联用户故事**: US-006 - 标记待办事项完成状态

**优先级**: P0

### 标准描述
支持通过 PUT 更新状态字段，并记录状态变更时间。

### 验证场景

#### 场景 1: PUT 更新状态
**Given** 用户创建了待办事项
**When** 用户向 `/api/todos/1` PUT:
```json
{
  "status": "COMPLETED"
}
```
**Then** 系统应该:
- 更新状态
- 设置 completed_at 时间戳
- 返回更新后的待办事项

**测试用例**: TC-022-01

#### 场景 2: 权限验证
**Given** 用户 A 创建了待办事项
**When** 用户 B 尝试更新状态
**Then** 系统应该返回 403 Forbidden

**测试用例**: TC-022-02

### 验证方法
- [x] 自动化测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-023: 创建分类标签

**关联用户故事**: US-007 - 管理分类和标签

**优先级**: P1

### 标准描述
用户能够创建分类和标签，设置名称和颜色。

### 验证场景

#### 场景 1: 创建分类
**Given** 用户已登录
**When** 用户向 `/api/categories` POST:
```json
{
  "name": "工作",
  "color": "#FF0000"
}
```
**Then** 系统应该:
- 创建分类
- 关联到当前用户
- 返回分类信息

**测试用例**: TC-023-01

#### 场景 2: 颜色验证
**Given** 用户已登录
**When** 用户提交无效的颜色格式
**Then** 系统应该返回 400 Bad Request

**测试用例**: TC-023-02

### 验证方法
- [x] 自动化测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-024: 分类名称唯一性

**关联用户故事**: US-007 - 管理分类和标签

**优先级**: P1

### 标准描述
同一用户下的分类名称必须唯一。

### 验证场景

#### 场景 1: 重复分类名称
**Given** 用户创建了分类 "工作"
**When** 用户尝试创建同名分类
**Then** 系统应该返回 400 Bad Request 并提示"分类名称已存在"

**测试用例**: TC-024-01

#### 场景 2: 不同用户可以有相同分类
**Given** 用户 A 创建了分类 "工作"
**When** 用户 B 创建分类 "工作"
**Then** 系统应该允许创建

**测试用例**: TC-024-02

### 验证方法
- [x] 自动化测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-025: 删除分类验证

**关联用户故事**: US-007 - 管理分类和标签

**优先级**: P1

### 标准描述
未使用的分类可以删除，已使用的分类无法删除。

### 验证场景

#### 场景 1: 删除未使用的分类
**Given** 用户创建了分类但未使用
**When** 用户删除分类
**Then** 系统应该成功删除

**测试用例**: TC-025-01

#### 场景 2: 删除已使用的分类
**Given** 用户创建了分类并有待办事项使用
**When** 用户尝试删除分类
**Then** 系统应该返回 400 Bad Request 并提示"分类已被使用，无法删除"

**测试用例**: TC-025-02

### 验证方法
- [x] 自动化测试
- [x] 关联检查

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-026: 修改密码功能

**关联用户故事**: US-008: 修改个人信息和密码

**优先级**: P1

### 标准描述
用户能够修改密码，需要验证旧密码。

### 验证场景

#### 场景 1: 修改密码成功
**Given** 用户已登录
**When** 用户向 `/api/user/change-password` POST:
```json
{
  "oldPassword": "Test1234",
  "newPassword": "NewPass567"
}
```
**Then** 系统应该:
- 验证旧密码正确
- 更新密码
- 要求用户重新登录

**测试用例**: TC-026-01

#### 场景 2: 旧密码错误
**Given** 用户已登录
**When** 用户提交错误的旧密码
**Then** 系统应该返回 400 Bad Request 并提示"旧密码错误"

**测试用例**: TC-026-02

### 验证方法
- [x] 自动化测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-027: 搜索待办事项

**关联用户故事**: US-009: 搜索待办事项

**优先级**: P1

### 标准描述
用户能够通过关键词搜索待办事项的标题和描述。

### 验证场景

#### 场景 1: 标题搜索
**Given** 用户创建了待办事项 "完成项目报告"
**When** 用户搜索关键词 "项目"
**Then** 系统应该返回匹配的待办事项

**测试用例**: TC-027-01

#### 场景 2: 描述搜索
**Given** 用户创建了待办事项，描述为 "需要在周五之前完成"
**When** 用户搜索关键词 "周五"
**Then** 系统应该返回匹配的待办事项

**测试用例**: TC-027-02

#### 场景 3: 搜索无结果
**Given** 用户创建了待办事项
**When** 用户搜索不存在的关键词
**Then** 系统应该返回空列表

**测试用例**: TC-027-03

### 验证方法
- [x] 自动化测试
- [x] 模糊查询测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## AC-028: 过滤待办事项

**关联用户故事**: US-010: 过滤待办事项

**优先级**: P1

### 标准描述
用户能够按状态、优先级、截止日期、分类过滤待办事项。

### 验证场景

#### 场景 1: 按状态过滤
**Given** 用户有多个待办事项
**When** 用户过滤状态 "PENDING"
**Then** 系统应该只返回待处理状态的待办事项

**测试用例**: TC-028-01

#### 场景 2: 组合过滤
**Given** 用户有多个待办事项
**When** 用户过滤状态 "PENDING" 和优先级 "HIGH"
**Then** 系统应该返回同时满足两个条件的待办事项

**测试用例**: TC-028-02

#### 场景 3: 清空过滤
**Given** 用户已应用过滤条件
**When** 用户清空所有过滤条件
**Then** 系统应该返回所有待办事项

**测试用例**: TC-028-03

### 验证方法
- [x] 自动化测试
- [x] 多条件查询测试

### 验证结果
- [ ] 通过
- [ ] 失败
- [ ] 阻塞

**验证人**: 待定
**验证日期**: 待定

---

## 验收标准编写指南

### 1. Given-When-Then (GWT) 格式

每个验收标准使用 GWT 格式：

**Given** (前置条件)
- 描述测试开始前的系统状态
- 用户已经登录
- 数据已经准备

**When** (操作)
- 描述用户执行的操作
- 点击按钮
- 输入数据

**Then** (预期结果)
- 描述系统应该的反应
- 显示成功消息
- 数据被保存

### 2. 验收标准应该 SMART

- **S**pecific (具体): 清晰明确，无歧义
- **M**easurable (可衡量): 可以量化验证
- **A**chievable (可达成): 技术上可以实现
- **R**elevant (相关): 与用户故事相关
- **T**ime-boxed (有时限): 可以在合理时间内验证

### 3. 验证场景应该全面

每个验收标准考虑：
- 正常流程 (Happy Path)
- 边界情况
- 异常情况
- 错误处理

### 4. 验证方法

根据验收标准类型选择验证方法：

| 标准类型 | 推荐验证方法 |
|----------|--------------|
| 功能性   | 自动化测试 + 手动测试 |
| 性能     | 性能测试 |
| 安全     | 安全扫描 + 渗透测试 |
| 可用性   | 用户测试 |
| 兼容性   | 兼容性测试 |

---

## 验收标准检查清单

在完成验收标准时，使用此检查清单：

- [x] 所有验收标准都已编写
- [x] 每个标准都使用 GWT 格式
- [x] 每个标准都考虑了正常和异常场景
- [x] 每个标准都有明确的验证方法
- [x] 每个标准都可测试验证
- [x] 验收标准与用户故事一致
- [x] 验收标准之间没有冲突
- [x] 所有验收标准都有优先级
- [x] 所有验收标准都有测试用例编号
